那在裸机的 OS 怎么启动呢？首先启动 RustSBI  (可以理解为 bios)，RustSBI 固定调用 0x80020000 ，而根据 Link.ld ，0x80020000 放着 text.entry ，根据  entry.asm 的 .text.entry 段里的汇编代码，声明了 stack 并调用 rust_main 函数。rust_main 函数调用了输出宏，实际通过 system call 调用 RustSBI 来输出，RustSBI 通过串口硬件来完成。

在裸机上输出可不容易。

1. 需要 Linker.ld 是指定内存布局，再指定从哪开始。
2. 需要建立堆栈 entry.asm，才能调用函数。建立 stack 做什么呢？编译器用 stack 来保存和恢复寄存器。

1 决定了怎么启动，2 完成才可以调用 rust_main ，具体可以参考下面的汇编。

附录：

```assembly
    .section .text.entry1
    .globl _start2
_start2:
    la sp, boot_stack_top
    call rust_main

    .section .bss.stack
    .globl boot_stack
boot_stack:
    .space 4096 * 16
    .globl boot_stack_top
boot_stack_top:
```

```
OUTPUT_ARCH(riscv)
/* ENTRY(_start3) */
BASE_ADDRESS = 0x80020000;

SECTIONS
{
    . = BASE_ADDRESS;
    skernel = .;

    stext = .;
    .text : {
        *(.text.entry1)
        *(.text .text.*)
    }

    . = ALIGN(4K);
    etext = .;
    srodata = .;
    .rodata : {
        *(.rodata .rodata.*)
        *(.srodata .srodata.*)
    }

    . = ALIGN(4K);
    erodata = .;
    sdata = .;
    .data : {
        *(.data .data.*)
        *(.sdata .sdata.*)
    }

    . = ALIGN(4K);
    edata = .;
    .bss : {
        *(.bss.stack)
        sbss = .;
        *(.bss .bss.*)
        *(.sbss .sbss.*)
    }

    . = ALIGN(4K);
    ebss = .;
    ekernel = .;
    bugu = .;

    /DISCARD/ : {
        *(.eh_frame)
    }
}
```




- Linker.ld 给内存布局，text 段对应代码，bss 对应未赋值的全局变量，rodata 对应只读全局变量，data 对应数据。