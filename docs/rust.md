在 Rust 中，与动态内存分配相关的智能指针主要有如下这些：

- `Box<T>` 在创建时会在堆上分配一个类型为 `T` 的变量，它自身也只保存在堆上的那个变量的位置。而和裸指针或引用 不同的是，当 `Box<T>` 被回收的时候，它指向的那个变量（位于堆上）也会被回收。`Box<T>` 可以对标 C++ 的 `std::unique_ptr` 。

- `Rc<T>` 是一个单线程上使用的引用计数类型，它提供了 多所有权支持，即可同时存在多个智能指针指向同一个堆上变量的 `Rc<T>` ，它们都可以拿到指向变量的不可变引用来 访问这同一个变量。而它同时也是一个引用计数，事实上在堆上的另一个位置维护了堆上这个变量目前被引用了多少次， 也就是存在多少个 `Rc<T>` 智能指针。这个计数会随着 `Rc<T>` 智能指针的创建或复制而增加，并在 `Rc<T>` 智能指针生命周期结束 时减少。当这个计数变为零之后，这个智能指针变量本身以及被引用的变量都会被回收。 `Arc<T>` 与 `Rc<T>` 功能相同，只是``Arc<T>`` 可以在多线程上使用。 `Arc<T>` 类似于 C++ 的 `std::shared_ptr` 。

- `RefCell<T>` 与 `Box<T>` 等智能指针不同，其 **借用检查** 在运行时进行。对于 RefCell<T>，如果违反借用规则，程序会编译通过，但会在运行时 panic 并退出。使用 `RefCell<T>` 的好处是，可在其自身是不可变的情况下修改其内部的值。在Rust语言中，在不可变值内部改变值是一种 [内部可变性](https://rcore-os.github.io/rCore-Tutorial-Book-v3/chapter2/3batch-system.html#term-interior-mutability) 的设计模式。

- `Mutex<T>` 是一个互斥锁，在多线程中使用，它可以保护里层被动态分配到堆上的变量同一时间只有一个线程能对它 进行操作，从而避免数据竞争，这是并发安全的问题，会在后面详细说明。同时，它也能够提供 [内部可变性](https://rcore-os.github.io/rCore-Tutorial-Book-v3/chapter2/3batch-system.html#term-interior-mutability) 。`Mutex<T>` 时常和 `Arc<T>` 配套使用，因为它是用来 保护多线程（线程概念在后面会讲，这里可简单理解为运行程序）可同时访问的数据，其前提就是多个线程都拿到指向同一块堆上数据的 `Mutex<T>` 。于是，要么 这个 `Mutex<T>` 作为全局变量被分配到数据段上，要么将 `Mutex<T>` 包裹上一层多所有权变成 `Arc<Mutex<T>>` ，让它可以在线程间进行传递。请记住 `Arc<Mutex<T>>` 这个经典组合，我们后面会用到。

  在讲解 **同步互斥** 之前我们通过 `RefCell<T>` 来获得内部可变性。可以将 `Mutex<T>` 看成 `RefCell<T>` 的多线程版本， 因为 `RefCell<T>` 是只能在单线程上使用的。而且 `RefCell<T>` 并不会在堆上分配内存，它仅用于基于数据段的静态内存 分配。