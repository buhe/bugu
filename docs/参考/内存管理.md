应用都通过物理内存来访问有什么问题呢？(参考 rCore)

- 首先，内核提供给应用的内存访问接口不够透明，也不好用。由于应用直接访问物理内存，这需要它在构建的时候就清楚所运行计算机的物理内存空间布局，还需规划自己需要被加载到哪个地址运行。为了避免冲突可能还需要应用的开发者们对此进行协商，这显然是一件在今天看来不够通用且极端麻烦的事情。
- 其次，内核并没有对应用的访存行为进行任何保护措施，每个应用都有计算机系统中整个物理内存的读写权力。即使应用被限制在 U 特权级下运行，它还是能够造成很多麻烦：比如它可以读写其他应用的数据来窃取信息或者破坏其它应用的正常运行；甚至它还可以修改内核的代码段来替换掉原本的 `trap_handler` 函数，来挟持内核执行恶意代码。总之，这造成系统既不安全、也不稳定。
- 再次，目前应用的内存使用空间在其运行前已经限定死了，内核不能灵活地给应用程序提供的运行时动态可用内存空间。比如一个应用结束后，这个应用所占的空间就被释放了，但这块空间无法动态地给其它还在运行的应用使用。

内存管理需要硬件支持。 

堆不是必须建立在虚拟内存上的，也可以建立在物理内存，所以动态内存分配和虚拟内存是分开的。动态内存分配通常建立在虚拟内存之上。

无论是不是恒等还是栈分配都用三级页表，之所以内核能用恒等，而应用用栈是因为内核可以从 0x80020000 开始(见 linker-k210.ld)，应用从 0 开始。

