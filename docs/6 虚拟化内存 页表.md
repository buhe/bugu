### 虚拟化内存

虚拟化完 CPU 后，我们虚拟化内存。为什么虚拟化内存呢？

- 之前应用使用物理内存，需要指定具体的地址，如 0x80400000 ，如果应用一个个执行还好，下一章会看到为了最大化 CPU 的利用率，应用往往是并行运行的，这就需要应用间线下协商。
- 如果每个应用都能通过地址访问物理内存，应用就可以为所欲为，为了安全也需要虚拟化。

内存怎么虚拟化，历史上经历了分应用 -> 应用的具体段 -> 两种方法结合 -> 最后因为内、外内存碎片的原因我们采用了页表算法，实际上，x86的64位模式甚至不再支持分段，而是使用分页，这完全避免了碎片问题。因为页一般大小相同所以外碎片很少，页相对很小内碎片可以忽略不计。问题变成

- 缩小页表占用的空间
- 访问内存的速度

我们的目标还是打印，不同的是这次迁移到虚拟化内存。

所谓虚拟化内存就是虚拟内存，好像什么也没说，在访问内存前经过映射关系的一次变换，那映射关系就要保存起来。每一个应用的映射关系保存在内存中，这个数据结构就是页表，每一个映射关系是一个页表项。

这些映射是内核做的，内核同时也是一个“应用”，也访问的是虚拟地址，好像套娃。。比如访问 0x1234 其实有一个映射是 0x1234 -> 0x4321 ，实际的内存地址其实是 0x4321 ，而这个映射就在这个应用的页表里，这个映射是其中一个页表项。

一个页现代操作系统都是 4k ,也就是说映射是以 4k 为单位的，后 12 位（4k 等于 2 的 12 次方）是偏移。前面的位数组成虚拟页号和物理页号，risc-v 有 39 和 48 两种标准，我们选择前者，也就是 虚拟页号有 39 - 12 = 27 位，也就是需要 2 的 27 方个映射关系。

![page-table](https://tva1.sinaimg.cn/large/008i3skNgy1gv0q8e7ab4j60us0hyjtz02.jpg)

(图片来自 https://rcore-os.github.io/rCore-Tutorial-Book-v3/chapter4/2address-space.html 侵删)

![satp](https://tva1.sinaimg.cn/large/008i3skNly1gv0rz604gyj60y305hwf402.jpg)



![sv39-va-pa](https://tva1.sinaimg.cn/large/008i3skNly1gv0s4n28w0j60sh084dgd02.jpg)



### TLB

TLB 加速，这也就是平时我们写程序的时候为什么要注意空间和时间的局部性。